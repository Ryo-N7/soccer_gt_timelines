---
always_allow_html: yes
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction


Despite recent advances that have overtaken xG

measuring shot quality instead of simply looking at the lump sum of shots taken (off and on target) by one team compared to the other. 

expected goals as a concept is still the most widely-accepted metric by the general public. 



For R users who want to dabble I highly recommend the following:

- 

- 

I started out in soccer analytics mainly to practice my data cleaning and visualization skills and over time it evolved into an entire portfolio of plots and graphs that you can see in []().

At the beginning of last season I figured out how to grab match-level data from [understat.com]() via [Ewen Henderson]()'s [{understatr}]() package and set about creating a "matchday summary graphic". These were intended to visualize the data understat.com provided in my own aesthetically-pleasing way for the general public. 

Version 1 looked like this:

![]()

In the past few months after the Corona extended season ended I intended to make tweaks to the graph above but instead I just started creating other views with the data available while also incorporating some other stuff that I couldn't fit into the original match day viz. 

![look-over-meme]()
"Tweak and improve existing data viz." <> "Create new viz from scratch."

One of the new viz I created was a chronological table of shots during the course of the match which provides the viewer with a lot more details about any single shot. Besides the xG value, things like the "situation" (open play? free kick? etc.), "shot type" (right, left, header), etc. were added for more context. 



2nd season so build MORE for more context 




# Target Audience

# Design Choices


The color-coding of the rows is intended to give you a clear idea of who were dominating shots at any given time period at a glance without even looking too closely at the details. Of course there may be a ton of shots in a small period of time or vice-versa which can skew your perception if you don't look at the "minute" column closely. 



- sparkline timeline: no, cum xg covers that and can't see plot point easily in graph. also the nature of the chronological setup already means you get that aspect of the game anyways
better to focus on something that's easier to see at first glance as highlights the main idea of the table >> shost. 

bold text
emphasize GOALS, OWN GOALS 
add emoji to further highlight (regular version uses a star emoji instead due to HTML-to-PNG conversion issues)

title text: different sizes >> focus on actual score line then down to xG 


Concerns:

large size of file

inexperience with HTML/CSS to get team logos to slot in on either side of the title text.

necessity to be careful about what colors to use as the main team colors (yellow for example is strictly off-limits)


# Data

Data source: understat.com

Definitions for some variables are provided by hovering over column names on the website. Others are opaque but follow same terminology set by other data companies and websites. 

Largest concern is over the accuracy of the xG model that understat uses to produce the xG values for shots. 

Used by regular public and journalists but there's never been any info given to ______ 

Most websites don't due to competitiveness of the analytics space 

but that is the biggest caveat with using the data as I'm not in control over the specific outputs of these calculated statistics. 

For the average Joe this along with the more recent FBref (advanced metrics provided by StatsBomb) are the best free and publically available websites for obtaining this type of data. 

It would be a point of interest to create my own xG model based on the variables provided on understat.com by following some of the "how-to" blog posts around the web.


## Shape of data

Now let's go over what are the data frames you need to create these tables and plots. 


1. shots_df = match_shots_data_clean




2. rollsum_xG = match_rollsumxG





3. home_stats & away_stats 



# Code Breakdown


## Other arguments


- team_name 


- team_color 


- match_date





## Creating the soccer field plots



- custom_pitch specification via {ggsoccer}

For the actual soccer field I use the {ggsoccer} package. Along with the pitch dimension specifications for data sources like Opta, WyScout, and StatsBomb, the package also allows you to specify your own dimensions to fit your own data. If you want a bit more of an in-depth code through using the {ggsoccer} package, take a look at the package [README](https://github.com/Torvaney/ggsoccer) or have a look at one of my [first blog posts](https://ryo-n7.github.io/2018-06-29-visualize-worldcup/) where I create my own World Cup 2018 data and visualize it with {ggsoccer}. 

After playing around with the dimensions on understat the below are the measurements what I came up with and I defined it as a variable called `pitch_custom`. 

```{r}
pitch_custom <- list(
  length = 587,
  width = 373,
  penalty_box_length = 101,
  penalty_box_width = 211,
  six_yard_box_length = 31,
  six_yard_box_width = 111,
  penalty_spot_distance = 66,
  goal_width = 45,
  origin_x = 0,
  origin_y = 0)
```


- adjust coordinate data for vertical field view

Since we are orienting the shot maps vertically we need to convert the coordinates from the horizontal view to vertical. We are only using one side of the pitch we don't need to have different adjustments for the "home" and "away" teams. The new coordinates will be defined to the variables "X" and "Y" capitalized, the lower-case coordinates will be kept in just as a reference and for checking positions. Then we `select()` only the variables we need then capitalize "Goal" and "Own Goal" labels for the table (you could also use `stringr::str_to_upper()` here). 

```{r}
## create coords
match_df <- shots_df %>% 
  ## switch coordinates for vertical view
  mutate(
    x = case_when(
      h_a == "a" ~ X * 587,
      h_a == "h" ~ X * 587,
      TRUE ~ 0),
    y = case_when(
      h_a == "a" ~ Y * 373,
      h_a == "h" ~ Y * 373,
      TRUE ~ 0)) %>%
  select(minute, player, team_name, 
         result, x, X, y, Y, xG) %>% 
  mutate(result = case_when(
    result == "Goal" ~ "GOAL",
    result == "Own Goal" ~ "OWN GOAL",
    TRUE ~ result)) %>% 
  mutate(result = forcats::as_factor(result)) %>% 
  mutate(result = forcats::fct_relevel(result, "GOAL", "Saved Shot",
                                       "On Post", "Blocked Shot", 
                                       "Missed Shots", "OWN GOAL"))
```

This is how the data looks like now. There's a row for every shot in chronological order along with the coordinates for the shots.

```{r}
glimpse(match_df)
```

Using this data frame we can create shot map plots that will serve as the base for a more detailed plot in a later section.

- function to define base shot map

This function will take the `data` and `team_name` inputs that come from the `match_df` data frame that we just created. This plot will plot **all** shots per team for every row of the data frame. After using `filter()` to only get the shots for the specific team, `annotate_pitch()` is used to create the pitch object using the dimensions we specified in `pitch_custom` earlier. The `theme_pitch()` is a helper function for {ggsoccer} that removes all the background and axes details while `coord_flip()` is used to flip the field so that the goal is at the top of the plot. All the shots will be grey and transparent (via the 'alpha' argument) as later on we will highlight the actual shot for a specific row in our table in a different plotting function. 

```{r}
create_shotmap_basic <- function(df = data, team_name = team_name) {
  
  shotxG_map_raw <- 
    ggplot(df %>% filter(team_name == team_name), 
           aes(x = x, y = y)) +
    annotate_pitch(dimensions = pitch_custom) +
    ## all shots in grey and transparent
    geom_point(aes(x = x, y = y), color = "grey20", 
               size = 3, alpha = 0.3) +
    scale_x_continuous(expand = c(0.01, 0)) +
    theme_pitch(aspect_ratio = 373/587) +
    coord_flip(xlim = c(280, 590), # c(280, 590)
               ylim = c(10, 365)) + # c(-1, 373)
    theme(plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "pt"),
          text = element_markdown(family = "Roboto Condensed"),
          legend.position = "none")    
  
  return(shotxG_map_raw)
}
```



Using the above function now we need to 

We `nest()` the data by "team_name" so that when we plot our basic shot maps each row will plot all the shots for the specified team in "team_name". By "nesting" the data this way we can apply the plotting function to **all** the data for **each** team. This way we won't be plotting a basic shot map using shot data from both teams. 

```{r}
match_df %>% tibble::as_tibble() %>% group_by(team_name) %>% nest()
```

The "data" column contains **all** the data that we saw previously for each team. If we `unnest()` the "data" column for the row with "Liverpool" in the "team_name" column we can see that it contains all the data seen previously but **only** for Liverpool. The same will apply if we "unpack" the "data" column for the row with Leeds United. 

```{r}
match_df %>% 
  tibble::as_tibble() %>% 
  group_by(team_name) %>% 
  nest() %>% 
  head(1) %>% 
  unnest()
```


With this data structure in hand, we apply the basic shot map plot function to every row of data inside the "data" column for both teams. We can do this by passing the "data" and "team_name" columns as the arguments to the shot map function which then iterates over every row in each team's "data" column. 

```{r}
## add blank shot map to all rows
match_df_basic_plot <- match_df %>% 
  tibble::as_tibble() %>% 
  ## nest by team
  group_by(team_name) %>% 
  nest() %>% 
  ## add all shots per team for each row
  mutate(plot = map2(data, team_name, create_shotmap_basic))
```

When we take a `glimpse()` at our data frame we now see an additional column, "plot" that houses plots for each row of shots for both teams. 
So Liverpool took 22 total shots and therefore have 22 rows inside "data" which results in 22 plots while for Leeds there are 6, 6, and 6 of the same. 

```{r}
glimpse(match_df_basic_plot)
```





```{r}
  ## clean cumsum df
  match_rollsum_simple <- roll_sum_df %>% 
    ## take out blank rows with xG = 0
    filter(xG != 0.00) %>% 
    select(minute_2 = minute, firstname, team_name, xG, minute_goal, rollsum_goal,
           situation, shotType, player_assisted, lastAction)
  
  ## join together cumsum df with plot df
  ## this is so after 'basic plot' is turned into a nested df
  ## the columns that were "lost" inside the nesting are added back in
  dfdf <- match_df %>% 
    left_join(match_df_basic_plot) %>% 
    left_join(match_rollsum_simple, 
              by = c("xG", "team_name", "minute" = "minute_2")) %>% 
    ## make sure its in chrnological order
    arrange(minute)
```






- function to define specific shot map

This second plotting function takes the plots we will create with the previous function and adds in the specific shot for each row to the base plot. The "plot" that is being passed into this function are all the plots saved in a "plot" column of the data frame. 


```{r}
add_xG_shot <- function(x, y, xG, plot) {
  fill_cols <- c("Goal" = "#1a9641",
                 "Saved Shot" = "orange",
                 "Blocked Shot" = "grey",
                 "Missed Shot" = "black",
                 "Own Goal" = "#d7191c",
                 "On Post" = "#004CFF")
  
  shotxG_map_point <- 
    plot +
    # specific shot point in black and bold
    geom_point(x = x, y = y, color = "black", 
               size = 12) +
    scale_x_continuous(expand = c(0.01, 0)) +
    scale_color_manual(values = fill_cols, guide = NA) +
    ## label for shot point
    geom_label(x = 318, y = 186.5, 
               color = "black", size = 20,
               fill = "white", family = "Roboto Slab",
               label = glue::glue("{xG} xG"))
  
  return(shotxG_map_point)
}
```



## Combining plots to data frame


- 



shot points could be color of team. rather keep consistently black as some colors might not work so well as solid points >>> use black as the stroke outline?







## Actual table




Image files need to be placed in output folder

## Save online to RPubs





# Acknowledgements


# Conclusion & Future Steps



DARK MODE!



